import os

from infosec import core as utils


MSGCHECK = './msgcheck'


@utils.smoke.smoke_check
def check_q1a():
    with utils.in_directory('q1'):
        with utils.smoke.get_from_module('q1a.py', 'check_message') as check_message:
            if not check_message('01.msg'):
                raise utils.SmoketestFailure(
                    'q1a.check_message on "01.msg" should return True'
                )
            if check_message('02.msg'):
                raise utils.SmoketestFailure(
                    'q1a.check_message on "02.msg" should return False'
                )


@utils.smoke.smoke_check
def check_fix(module_name, file_path='02.msg'):
    fixed_path = file_path + '.fixed'
    with utils.in_directory('q1'):
        with utils.smoke.get_from_module(module_name, 'fix_message') as fix_message:
            fix_message(file_path)
            if utils.execute([MSGCHECK, fixed_path]).exit_code != 0:
                raise utils.SmoketestFailure(
                    f'{MSGCHECK} failed on {fixed_path} (generated by {module_name})'
                )


def patch_and_chmod(module_path, program_path):
    patched_path = program_path + '.patched'
    with utils.smoke.get_from_module(module_path, 'patch_program') as patch_program:
        patch_program(program_path)
        if not os.path.isfile(patched_path):
            raise utils.SmoketestFailure(
                f'Error generating "{patched_path}" with {module_path}'
            )
        os.chmod(patched_path, 0o700)
        return patched_path


@utils.smoke.smoke_check
def check_patch(module_name):
    with utils.in_directory('q1'):
        patched_path = patch_and_chmod(module_name, MSGCHECK)
        if utils.execute([patched_path, '02.msg']).exit_code != 0:
            raise utils.SmoketestFailure(
                f'{patched_path} (generated by {module_name}) failed on 02.msg'
            )


@utils.smoke.smoke_check
def check_q2():
    with utils.in_directory('q2'):
        patched_path = patch_and_chmod('q2.py', './readfile')
        result = utils.execute([patched_path, '1.txt'])
        if result.exit_code != 0:
            raise utils.SmoketestFailure(
                f'{[patched_path]} (generated by q2.py) failed on 1.txt'
            )
        if '#!' in result.stdout:
            raise utils.SmoketestFailure(
                f"{[patched_path]} doesn't seem to work as expected on 1.txt"
            )


def smoketest():
    os.chdir(os.path.dirname(os.path.abspath(__file__)))
    check_q1a()
    utils.smoke.check_if_nonempty('q1/q1a.txt')
    check_fix('q1b.py')
    utils.smoke.check_if_nonempty('q1/q1b.txt')
    check_fix('q1c.py')
    utils.smoke.check_if_nonempty('q1/q1c.txt')
    check_patch('q1d.py')
    utils.smoke.check_if_nonempty('q1/q1d.txt')
    check_patch('q1e.py')
    utils.smoke.check_if_nonempty('q1/q1e.txt')
    check_patch('q1e.py')
    utils.smoke.check_if_nonempty('q1/q1e.txt')
    check_q2()
    utils.smoke.check_if_nonempty('q2/patch1.asm')
    utils.smoke.check_if_nonempty('q2/patch2.asm')
    utils.smoke.check_if_nonempty('q2/q2.txt')


if __name__ == '__main__':
    smoketest()
